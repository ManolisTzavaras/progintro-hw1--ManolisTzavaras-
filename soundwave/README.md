Εισαγωγή

Ο παρακάτω κώδικας έχει σκοπό να ελέγχει αν ένα αρχείο ήχου τύπου WAV είναι σωστό και να εμφανίζει βασικές πληροφορίες γι’ αυτό. Το πρόγραμμα διαβάζει το αρχείο από την τυπική είσοδο και χρησιμοποιείται με την εντολή info. Με απλά λόγια, προσπαθώ να καταλάβω αν το αρχείο ακολουθεί σωστά τη μορφή WAV και αν τα στοιχεία του έχουν νόημα.

"Βιβλιοθήκες" και αρχικά σχόλια

Στην αρχή του κώδικα υπάρχουν κάποιες βασικές, με άλλα λόγια, "βιβλιοθήκες" για είσοδο και έξοδο, χειρισμό μνήμης και αριθμητικές πράξεις.

Συνάρτηση readb()

Στη συνέχεια, ορίζω τη συνάρτηση readb(), η οποία διαβάζει ένα byte από το αρχείο. Αν φτάσει στο τέλος του αρχείου, επιστρέφει -1. Αυτή η συνάρτηση είναι σημαντική γιατί το αρχείο διαβάζεται byte προς byte, κάτι που είναι απαραίτητο για δυαδικά αρχεία όπως τα WAV.

Συνάρτηση read_n()

Η επόμενη συνάρτηση, read_n(), διαβάζει συγκεκριμένο αριθμό bytes και τα αποθηκεύει σε έναν πίνακα. Αν δεν υπάρχουν αρκετά bytes, επιστρέφει λάθος. Έτσι ελέγχω αν το αρχείο κόβεται απότομα ή είναι ελλιπές.

Μετατροπές endianness: u16() και u32()

Μετά, υπάρχουν οι συναρτήσεις u16() και u32() που μετατρέπουν δεδομένα από little endian μορφή σε κανονικούς ακέραιους αριθμούς, αφού οι αριθμοί στα αρχεία WAV αποθηκεύονται έτσι.

Αποθήκευση πληροφοριών κεφαλίδας

Στη συνέχεια, χρησιμοποιώ κάποιες γνωστές μεταβλητές για να αποθηκεύω τις πληροφορίες του header, όπως το μέγεθος του αρχείου, τον αριθμό καναλιών, το sample rate και τα bits ανά φορά. Αυτές οι μεταβλητές μου επιτρέπουν να χρησιμοποιώ τις πληροφορίες σε όλο το πρόγραμμα, χωρίς να περνάω από όλες τις γραμμές του κώδικα μέχρι να τις βρω.

Κύρια λογική: parse_header()

Η βασική δουλειά γίνεται στη συνάρτηση parse_header(). Εκεί ελέγχω αν το αρχείο ξεκινά με τη λέξη "RIFF" και στη συνέχεια με "WAVE", κάτι που είναι απαραίτητο για να είναι WAV. Αν κάτι από αυτά δεν ισχύει, το πρόγραμμα σταματά και εμφανίζει ένα μήνυμα στον χρήστη ότι κάτι πήγε λάθος. Μετά, ελέγχω το "fmt " chunk, όπου βλέπω αν το μέγεθος του format είναι 16 και αν ο τύπος ήχου είναι 1, δηλαδή απλό PCM.

Έλεγχοι καναλιών, sample rate και alignment

Έπειτα, ελέγχω αν το αρχείο είναι μονοφωνικό ή στερεοφωνικό (δυστυχώς), καθώς και το sample rate. Κάνω επίσης έναν έλεγχο (μαθηματικό) για να δω αν τα bytes ανά δευτερόλεπτο ταιριάζουν με το sample rate και το block alignment. Αυτό δείχνει αν τα στοιχεία του αρχείου είναι σωστά και δεν έχουν αλλοιωθεί. Επίσης, ελέγχω αν τα bits ανά sample είναι 8 ή 16, που είναι οι τιμές που υποστηρίζει το πρόγραμμα.

Έλεγχος δεδομένων ήχου: "data" chunk

Στο τέλος, διαβάζω το "data" chunk και το μέγεθος των δεδομένων ήχου. Μετράω πόσα bytes έχουν διαβαστεί συνολικά και ελέγχω αν το αρχείο έχει όσα δεδομένα λέει ότι έχει. Αν υπάρχουν λιγότερα ή περισσότερα bytes από τα αναμενόμενα, το πρόγραμμα εμφανίζει σφάλμα. (Τόσο απλά... όχι.)

Συνάρτηση main()

Η συνάρτηση main() ελέγχει τα ορίσματα του προγράμματος και αν δοθεί η εντολή info, καλεί τη συνάρτηση run_info() για να ξεκινήσει ο έλεγχος.

Συμπέρασμα

Γενικά, με αυτό το πρόγραμμα προσπαθώ να δείξω ότι καταλαβαίνω πώς είναι δομημένο ένα αρχείο WAV και πώς μπορούμε να το ελέγξουμε βήμα προς βήμα, διαβάζοντας τα δεδομένα του και κάνοντας βασικούς ελέγχους για να βεβαιωθούμε ότι είναι σωστό.
